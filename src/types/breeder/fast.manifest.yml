id: breeder/fast

composer: |

  # Determine the correct order in which to construct each of the breeding
  # sources.
  srcs = collect(keys(Dict{ASCIIString, Any}(s["sources"])))
  i = 1
  while i < length(srcs)
    gt_i = findfirst(srcs) do j
      haskey(s["sources"][srcs[i]], "source") && s["sources"][srcs[i]]["source"] == j
    end
    if gt_i != 0 && gt_i > i
      srcs[gt_i], srcs[i] = srcs[i], srcs[gt_i]
    else
      i += 1
    end
  end

  # Create each of the breeding sources, in the established order.
  for sn in srcs
    ss = s["sources"][sn]
    if ss["type"] == "variation" && haskey(ss, "source")
      ss["source"] = s["sources"][ss["source"]]
      ss["stage"] = s["species"].stages[Base.get(ss, "stage", "genome")]
    end
    s["sources"][sn] = compose_as(ss, "breeder/fast:source/$(ss["type"])")
  end
  
  # Create the breeder using the final breeding source.
  # Annoyingly OrderedDict doesn't implement an endof(), nor does
  # its iterator, and so we have to collect its values before determining
  # which is the last.
  build_sync(s["species"], FastBreeder(s["species"], s["sources"][srcs[end]]))
