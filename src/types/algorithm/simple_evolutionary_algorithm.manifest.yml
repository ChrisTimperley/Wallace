id: algorithm/simple_evolutionary_algorithm

properties:
  replacement:
    type:         replacement
    default:      replacement/generational
    description:  >
      The replacement scheme used to determine the individuals carried forward
      within each deme at the end of each generation from its set of existing
      members and its set of offspring.

composer: |
  s["output"] = abspath(Base.get(s, "output", "output"))

  # If no type is provided for the population, proceed to use the full
  # population type.
  s["population"] = compose_as(s["population"],
    Base.get(s["population"], "type", "population"))

  # Default the replacement scheme to use generational replacement.
  println("Building replacement...")
  s["replacement"] = Base.get(s, "replacement",
    Dict("type" => "replacement/generational"))
  s["replacement"] = compose_as(s["replacement"], s["replacement"]["type"])
  
  println("Building evaluator...")
  s["evaluator"] = compose_as(s["evaluator"], s["evaluator"]["type"])

  println("Building loggers...")
  s["loggers"] = Logger[compose_as(lg, lg["type"]) for lg in Base.get(s, "loggers", [])]

  println("Building termination...")
  s["termination"] = Base.get(s, "termination", Dict{AbstractString, Criterion}())
  for t in keys(s["termination"])
    s["termination"][t] = compose_as(s["termination"][t], s["termination"][t]["type"])
  end
  s["termination"] = Dict{AbstractString, Criterion}(s["termination"])

  println("Putting it all together...")
  SimpleEvolutionaryAlgorithm(s["population"], s["evaluator"], s["replacement"],
    s["termination"], s["loggers"], s["output"])
